<!DOCTYPE html>
<html>
  <head>
    <title>Dynamic Programming</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

    <link href="css/slides.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <textarea id="source">

class: center, title-slide

<br><br>

## CSCI-UA 480: APS
## Algorithmic Problem Solving
<br/><br/><br/><br/><br/><br/><br/>
##  Dynamic Programming
### Maximum Sum Subarray Problem 



.author[
Instructor: Joanna Klukowska <br>
]


.license[
Copyright 2020 Joanna Klukowska. Unless noted otherwise all content is released under  a <br>
[Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/).<br>
Background image by Stewart Weiss<br>]


---
layout:true
template: default
name: section
class: inverse, middle, center

---
layout:true
template: default
name: challenge
class: challenge

---
layout:true
template: default
name: poll
class: inverse, full-height, center, middle

---
layout:true
template: default
name: breakout
class: breakout

---

layout:true
template:default
name:slide
class: slide

.bottom-left[&#169; Joanna Klukowska. CC-BY-SA.]






---
## Challenge: Max Sum Subarray

The __maximum sum subarray problem__ is the task of finding a contiguous subarray with the largest sum, within a given one-dimensional array `A[0..n-1]` of numbers.

__Example__

array `A = [-2, 1, -3, 4, -1, 2, 1, -5, 4]`

the subarray with the largest sum is `[4, -1, 2, 1]`, with sum `6`.

Write a program to calculate such sum with given input array.

--
.small[
__Input__

The first line contains an integer `n`, the number of elements in the input array, $1 <= n <= 100000$.

On the next line, there are `n` integers indicating the elements of the array. We have $-10^9 <= A[i] <= 
10^9$ for $0 <= i <= n-1$.

__Output__

Output one line containing the value of the sum for the  maximum subarray.

]

--

.left-column2[ 

__Example 1__

```
Input:
9
-2 1 -3 4 -1 2 1 -5 4

Output:
6

```
]
.right-column2[
__Example 2__

```
Input:
4
-3 -2 -4 -1

Output:
-1
```
]

---

## Greedy Approach 

__Idea / Algorithm__

- Start a sum. 
- Keep adding numbers as long as they are positive. 
- As soon as you hit a negative number, stop the current subarray (and record its sum) and start a new subarray, because a negative number will only make the sum smaller.

--

__This does not work.__ The last statement fails.

Example

`A = [10, -2, 10]`

The largest sum is 18 when we take all the values. But the above algorithm would report 10 as the max sum. 


---

## Brute Force - Take 1

This is the most straightforward, but also the slowest, approach.


__Idea__
Iterate through every possible pair of start, `i`, and end, `j` indices.
For each pair, iterate from i to j to calculate the sum of that subarray.

--

__Algorithm__

```
best = - INF 

for i in 0 .. N
    for j in i+1 .. N
        sum = 0
        for k in i .. j 
            sum = sum + A[k]
        if sum > best 
            best = sum 
return best 



```

--


__Complexity__ $O(N^3)$

---

## Brute Force - Take 2

We can improve the previous solution:

While iterating through all start, `i`, and end, `j` indices, we can avoid the third loop by keeping a running sum.

--



__Algorithm__

```
best = - INF 

for i in 0 .. N
    sum = 0 
    for j in i+1 .. N
        sum = sum + A[j] 
        if sum > best 
            best = sum 
return best 

```
--

__Complexity__ $O(N^2)$


--

Are there any further optimizations to this algorithm? 

---

## Divide and Conquer 


__Idea__  Use an approach similar to merge sort. 

The maximum subarray for a given array `A[i...j]` can be in one of three places:

- in the left half `A[i...mid]`

- in the right half `A[mid+1...j]`

- spanning the midpoint (a subarray that starts in the left half and ends in the right half).

---




## Divide and Conquer - Algorithm 

.left-column2-small[

`A[0...n-1]` - the given array 

`maxSubarra(i, j)`  - computes the max subarray between indexes `i` and `j`
]
--
.right-column2-large[

```
maxSubArray(i, j):
    if i == j:
        return A[i]       // only one element
```
]
--
.right-column2-large[
```
    mid = (i + j) / 2

    // solve in left and right halves
    leftMax  = maxSubArray(i, mid)
    rightMax = maxSubArray(mid + 1, j)
    
```
]
--
.right-column2-large[
```
    // compute best suffix of left half
    sum = 0
    bestLeftMiddle = -INF
    for l from mid down to i:
        sum += A[l]
        bestLeftMiddle = max(bestLeftMiddle, sum)
        
    // compute best prefix of right half
    sum = 0
    bestRightMiddle = -INF
    for r from mid + 1 up to j:
        sum += A[r]
        bestRightMiddle = max(bestRightMiddle, sum)
```
]
--
.right-column2-large[
```
    crossMax = bestLeftMiddle + bestRightMiddle

    return max(leftMax, rightMax, crossMax)

```
]

--

__Complexity__ $O(N\log N)$



---

## Another _Brute Force_, But Different 

__Idea__ At any index `i` in the array, we have two options:

- continue with the _current best_, i.e., with the currently computed best sum (this is not the best overall sum known so far)

- start a new _best_  

--


`A[0...n-1]` - the given array 

`bestEndingAt(i)` - maximum sum of a subarray that ends exactly at index `i`

`bestOverall(i)` - maximum sum of a subarray anywhere in `A[0..i]`

--

Recurrence relation: 

$$bestEndingAt(i) = max ( A[i], A[i]+bestEndingAt(i−1) )$$ 

$$bestOverall(i) = max ( bestOverall(i−1), bestEndingAt(i) ) $$


--

Base cases:

- $bestEndingAt(0) = A[0]$

- $bestOverall(0) = A[0]$



---

## Another _Brute Force_ (top-down)


.left-column2[

```
memoEnd[0..n-1]    - initialized to undefined 
memoEnd[0] = A[0]  - base case 



bestEndingAt(i)
    if i < 0:
        return -INF 

    if memoEnd[i] is defined:
        return memoEnd[i]

    if i == 0:
        memoEnd[0] = A[0]
    else:
        memoEnd[i] = max( A[i], 
                A[i] + bestEndingAt(i-1) )

    return memoEnd[i]


```
]
--
.right-column2[
```





bestOverall(i)
    if i < 0:
        return -INF
    
    best = -INF 
    
    if i == 0:
        best = A[0]
    else:
        best = max( bestOverall(i-1), 
                     bestEndingAt(i) )

    return best 

```
]

---

name:topdown1

## Another _Brute Force_ (top-down)


Example 

- `A = A = [3, -2, 5, -1, 4]`

- we need to trace `bestOverall(4)` 

---
template:topdown1
name:topdown2

.left-column2[

```
bestOverall(4)
 └─ needs bestOverall(3) and bestEndingAt(4)

bestOverall(3)
 └─ needs bestOverall(2) and bestEndingAt(3)

bestOverall(2)
 └─ needs bestOverall(1) and bestEndingAt(2)

bestOverall(1)
 └─ needs bestOverall(0) and bestEndingAt(1)

bestOverall(0)
 └─ base case: bestEndingAt(0) = A[0] = 3
    return 3

```
]

---
template:topdown2

.right-column2[

```
memoEnd = [3, undef, undef, undef, undef ]

bestEndingAt(1):
   uses bestEndingAt(0) -> memo hit (3)
   memoEnd[1] = max(-2, -2 + 3) = 1
   
bestOverall(1) = max(3, 1) = 3
return 3
```
]


---
template:topdown2

.right-column2[

```
memoEnd = [3, 1, undef, undef, undef ]

bestEndingAt(2):
   bestEndingAt(1) -> memo hit (1)
   memoEnd[2] = max(5, 5 + 1) = 6
   
bestOverall(2) = max(3, 6) = 6
return 6
```
]


---
template:topdown2

.right-column2[

```
memoEnd = [3, 1, 6, undef, undef ]

bestEndingAt(3):
   bestEndingAt(2) -> memo hit (6)
   memoEnd[3] = max(-1, -1 + 6) = 5
   
bestOverall(3) = max(6, 5) = 6
return 6
```
]


---
template:topdown2

.right-column2[

```
memoEnd = [3, 1, 6, 5, undef ]

bestEndingAt(4):
   bestEndingAt(3) -> memo hit (5)
   memoEnd[4] = max(4, 4 + 5) = 9
   
bestOverall(4) = max(6, 9) = 9
return 9
```
]


---


## Another _Brute Force_ (bottom-up)

```
A[0..n-1]                // given array
bestEndingAt[0] = A[0]   // max sum of subarray ending exactly at index 0
best = A[0]              // best subarray seen so far

for i from 1 to n-1:
    bestEndingAt[i] = max(A[i], A[i] + bestEndingAt[i-1])
    best = max(best, bestEndingAt[i])

return best

```
--



__Example  `A = A = [3, -2, 5, -1, 4]`__

```
i = 1:
    bestEndingAt[1] = max(-2, -2 + 3) = 1
    best = max(3, 1) = 3
```
--
```
i = 2:
    bestEndingAt[2] = max(5, 5 + 1) = 6
    best = max(3, 6) = 6
```
--
```
i = 3:
    bestEndingAt[3] = max(-1, -1 + 6) = 5
    best = max(6, 5) = 6
```
--
```
i = 4:
    bestEndingAt[4] = max(4, 4 + 5) = 9
    best = max(6, 9) = 9
```


</optgroup>



    </textarea>
     <script src="js/remark.js" type="text/javascript">
    </script>
    <script src="js/remark_conf.js" type="text/javascript">
    </script>

    <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<script type="text/x-mathjax-config">
   MathJax.Hub.Config({
     extensions: ["tex2jax.js"],
     jax: ["input/TeX", "output/HTML-CSS"],
     tex2jax: {
       inlineMath: [ ['$','$'], ["\\(","\\)"] ],
       displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
       processEscapes: true
     },
     "HTML-CSS": { availableFonts: ["TeX"] }
   });
</script>


  </body>
</html>
