<!DOCTYPE html>
<html>
  <head>
    <title>Non-Linear Data Structures</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

    <link href="css/slides.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <textarea id="source">

class: center, title-slide

<br><br>

## CSCI-UA 480: APS
## Algorithmic Problem Solving
<br/><br/><br/><br/><br/><br/><br/>
## Non-Linear Data Structures
### BST and Hash Table



.author[
Instructor: Joanna Klukowska <br>
]


.license[
Copyright 2020 Joanna Klukowska. Unless noted otherwise all content is released under  a <br>
[Creative Commons Attribution-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-sa/4.0/).<br>
Background image by Stewart Weiss<br>]


---
layout:true
template: default
name: section
class: inverse, middle, center

---
layout:true
template: default
name: challenge
class: challenge

---
layout:true
template: default
name: poll
class: inverse, full-height, center, middle

---
layout:true
template: default
name: breakout
class: breakout

---

layout:true
template:default
name:slide
class: slide

.bottom-left[&#169; Joanna Klukowska. CC-BY-SA.]



---
## Balanced Binary Search Tree

- binary tree
- for each node
  - all the values in the left subtree are smaller than the value in that node
  - all the values in the right subtree are greater than the value in that node
  - (equal values should be stored in one of the subtrees, if allowed)

--

- `map`/`set`/`multiset` in C++ and  `TreeMap` / `TreeSet` in Java

  - the _map_ versions of the classes store `(key, value)` pairs
  - the _set_ versions of the classes store only keys (which have to be unique)
  - the `multiset` (only in C++) allows duplicate keys

--

- $O(log N)$ on
  - add key,
  - remove key,
  - find key ,
  - find min/max,
  - successor/predecessor key

--

- AVL tree, Red-Black tree

---
template: challenge

## Challenge

For each o the following problems
1. come up with an algorithm(s) that can be used to solve
the problem,
1. what is the performance of your algorithms?

--


__Problem 1__ Given a root of a binary tree containing `N` nodes, determine
if it is a binary search tree?

__Problem 2__ Given a binary search tree containing `N` nodes,
output the elements with values in the range `[a..b]` in ascending
order. (`a` and `b` values are not guaranteed to be in the tree itself.
For simplicity, you can assume the values in nodes are integers.)

__Problem 3__ Given a binary search tree containing `N` nodes, output
the values in the leaves in ascending/descending order.

--

---------------------

- Assume that the trees for the above problems are created based on a sequence of insert operations.
- Assume that we are dealing with a plain old BST (no balancing).
- Assume that the depth of any tree is guaranteed not to ever reach a recursion depth limit.


What are some good test cases for the above problems?


---

template: challenge

## Challenge

Given a preorder traversal of a binary search tree, print its postorder traversal.

.left-column2[
Input:
```
50
30
24
5
28
45
98
52
60
```
]
.right-column2[
Output:
```
5
28
24
45
30
60
52
98
50
```
]

--

If you wish, you can try to submit it at https://vjudge.net/problem/UVA-12347



---

## Hash Table

- mapping from _keys_ to _values_ not sorted in any particular/predictable way

- lookups by key can be done in $O(1)$ (assuming a good hash function, but $O(N)$ worst case)

- addition / removal done in $O(1)$ (but $O(N)$ worst case)

--

- [`unordered_map`](http://www.cplusplus.com/reference/unordered_map/unordered_map/?kw=unordered_map)
in C++ () - starting in C++11 standard

- `HashMap`, `HashSet`, `HashTable` in Java

--

- challenge: depends on a well designed hash function
(and that is often tricky)

--

- Direct Addressing Table (DAT) is the simplest form of a hash
table in which _keys_ are the indexes - it is simply an array


---

class:challenge

## Snowflakes


<!-- https://dmoj.ca/problem/cco07p2 -->
You may have heard that no two snowflakes are alike. Your task is to write a program to determine whether this is really true.
Your program will read information about a collection of snowflakes, and search for a pair that may be identical.

Each snowflake has six arms. For each snowflake, your program will be provided with a measurement of the length
of each of the six arms. Any pair of snowflakes which have the same lengths of corresponding arms should be
flagged by your program as identical.

<!-- Note: The original CCO data were weak and have been augmented with some custom test cases.
Input Specification
-->
.small[
The first line of input will contain a single integer `n`, `0 < n ≤ 100000`, the number of snowflakes to follow.
This will be followed by `n` lines, each describing a snowflake.
Each snowflake will be described by a line containing six integers
(each integer is at least 0 and less than 10,000,000),
the lengths of the arms of the snowflake.
The lengths of the arms will be given in order around the snowflake (either clockwise or counterclockwise),
but they may begin with any of the six arms. For example, the same snowflake could be described as 1 2 3 4 5 6 or 4 3 2 1 6 5.
]

If all of the snowflakes are distinct, your program should print the message: "No two snowflakes are alike."

If there is a pair of possibly identical snowflakes, your program should print the message: "Twin snowflakes found."

Sample Input
```
2
1 2 3 4 5 6
4 3 2 1 6 5
```
Output for Sample Input
```
Twin snowflakes found.
```


---

class:challenge

## Snowflakes - Simplified


<!-- https://dmoj.ca/problem/cco07p2 -->
You may have heard that no two snowflakes are alike. Your task is to write a program to determine whether this is really true.
Your program will read information about a collection of snowflakes, and search for a pair that may be identical.

Each snowflake is represented by a single number. If the numbers are the same, the snowflakes are identical.

<!-- Note: The original CCO data were weak and have been augmented with some custom test cases.
Input Specification
-->

The first line of input will contain a single integer `n`, `0 < n ≤ 100000`, the number of snowflakes to follow.
This will be followed by `n` lines, each describing a snowflake.


If all of the snowflakes are distinct, your program should print the message: "No two snowflakes are alike."

If there is a pair of possibly identical snowflakes, your program should print the message: "Twin snowflakes found."


.left-column2[
Sample Input
```
2
1
1
```
Output for Sample Input
```
Twin snowflakes found.
```
]
.right-column2[
Sample Input
```
3
5
2
6
```
Output for Sample Input
```
No two snowflakes are alike.
```
]

---

## Snowflakes

If you feel up for a challenge to actually implement the solution, here are the links to VJudge:

- simplified version: https://vjudge.net/problem/Kattis-snowflakes (slightly different output than in our version)

- regular version: https://vjudge.net/problem/SPOJ-TWINSNOW


</optgroup>



    </textarea>
     <script src="js/remark.js" type="text/javascript">
    </script>
    <script src="js/remark_conf.js" type="text/javascript">
    </script>

    <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<script type="text/x-mathjax-config">
   MathJax.Hub.Config({
     extensions: ["tex2jax.js"],
     jax: ["input/TeX", "output/HTML-CSS"],
     tex2jax: {
       inlineMath: [ ['$','$'], ["\\(","\\)"] ],
       displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
       processEscapes: true
     },
     "HTML-CSS": { availableFonts: ["TeX"] }
   });
</script>


  </body>
</html>
