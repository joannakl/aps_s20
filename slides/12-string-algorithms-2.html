<!DOCTYPE html>
<html>
  <head>
    <title>String Algorithms</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

    <link href="css/slides.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <textarea id="source">

class: center, top

<br><br>

# CSCI-UA 480.4: APS
## Algorithmic Problem Solving
<br>
## Some String Algorithms


.author[
Instructor: Joanna Klukowska <br>

created based on materials for this class by Bowen Yu and
materials shared by the authors of the textbook  Steven and Felix Halim

]

.license[
Unless noted otherwise all content is released under [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/).
]

---
## String Definitions

a __string__ `s` of length $n$ consists of characters `s[0]`, `s[1]`, ..., `s[n-1]`

a __substring__ `s[a..b]` is a sequence of consecutive characters in a string
that starts at position `a` and ends at position `b` (inclusive on both ends)

a __prefix__ is a substring for which `a=0`

a __suffix__ is a substring for which `b=n-1`

a __subsequence__ is any sequence of characters in a string in their original
order (not necesserily consecutive)



---
# Longest Common Subsequence

The __longest common subsequence__ (lcs) of two strings is the longest string
that appears as a subsequence in both strings.

Examples:

- "floor" and "door", the lcs is "oor"
- "caged" and "rage", the lcs is "age"
- "capsule" and "recaps", the lcs is "caps"

--

__Solution__

given: two strings `x` and `y`

`lcs(i,j)` - function that returns length of the longest common
subsequence of the prefixes `x[0..i]` and `y[0..j]`

```
      lcs(i,j) =

         lcs(i-1,j-1)+1,      when  x[i]=y[j]

         max(lcs(i-1,j), lcs(i,j-1) ),  otherwise
```

--

[Visualization of the algorithm](https://www.cs.usfca.edu/~galles/visualization/DPLCS.html)



---

# Edit Distance

The __edit distance__ between two strings is defined as the minimum number
of editing operations that transform one string into the other.

The allowed operations may vary, but are often
- insert a character, "ABC" -> "ABCA"
- remove a character, "ABC" -> "AC"
- replace a character, "ABC" -> "ADC"
  (this one can be thought of as two separate operations of a remove followed by an insert,
or an insert followed by a remove)

--

__Solution__

given: two strings `x` and `y`

`edit(i,j)` - function that returns the edit distance between
the prefixes `x[0..i]` and `y[0..j]`

--

```
      edit(i,j) =  min (
              edit(i, j-1) + 1,
              edit(i-1, j) + 1,
              edit(i-1, j-1) + cost(i,j)
            )
```
where `cost(i,j) = 0` when `x[i]=y[j]` and `cost(i,j) = 1`, otherwise.



---

# Edit Distance

The __edit distance__ between two strings is defined as the minimum number
of editing operations that transform one string into the other.

The allowed operations may vary, but are often
- insert a character, "ABC" -> "ABCA"
- remove a character, "ABC" -> "AC"
- replace a character, "ABC" -> "ADC"
  (this one can be thought of as two separate operations of a remove followed by an insert,
or an insert followed by a remove)



__Solution__

given: two strings `x` and `y`

`edit(i,j)` - function that returns the edit distance between
the prefixes `x[0..i]` and `y[0..j]`



```
      edit(i,j) =  min (
              edit(i, j-1) + 1,           //insert character at the end of x
              edit(i-1, j) + 1,           //remove character from the end of x
              edit(i-1, j-1) + cost(i,j)  //replace the last char in x with the one from y
            )
```
where `cost(i,j) = 0` when `x[i]=y[j]` and `cost(i,j) = 1`, otherwise.


---
## Z-Array / Z-Algorithm / Z-Function

__What is a Z-array__?

--

The Z-array for a string `s` of length `n` is an array of length `n`
in which `Z[i]` stores the legnth of the longest substring starting
at `s[i]` that is also a prefix of `s`.

Example:

`s = "ABCABCABAB"`

```
index   0  1  2  3  4  5  6  7  8  9
  s     A  B  C  A  B  C  A  B  A  B
  Z     -  0  0  5  0  0  2  0  2  0

```


`s = "aaaaaa"`

```
index   0  1  2  3  4  5
  s     a  a  a  a  a  a
  Z     -  5  4  3  2  1

```


--

__What is a Z-Algorithm__?

--

It's an algorithm that computes the Z-Array for a given string `s`.

---
## Z-Algorithm - Take One

```
s - string for which we want to compute the z-array

z compute(s)
    n = length of s
    create z array of length n initialized to zero
    for i in 1...n
        while  ( i + z[i] < n)  &&   ( s[z[i]] == s[i + z[i]] )
            increment z[i] by 1
    return z

```
--

<br/>
<br/>
<br/>

works, but $O(n^2)$

--

if a substring repeats, we should be able to reuse previously calculated information

---
## Z-Algorithm - Take Two

- observer that for a character at index `i` of `s`, the value of `z[i]` implies
that substring starting at `i` and ending at `i+z[i]-1` _matches_ the prefix of `s`

--

- define a __segment__ to be a substring that matches the previx of `s`
--

- we'll keep track of indexes `[l,r]` that delimit the rightmost known segment (i.e., the one that ends
rightmost)

--
    - if current index `i > r`, then the position is outside of the region that
      we already processed and we compute `z[i]` comparing values one by one (i.e., using the _take one_ algorithm approach)

--
    - if current index `i<=r`, then the position is inside a segment that was already processed and
      we should be able to initialize `z[i]` based on what was computed previously

--
        - note that substrings `s[l...r]` and `s[0...r-l]` match,  so we can initialize `z[i]`
          to be equal to the corresponding value from the previously processed segment, i.e., `z[i-l]` <br/>
          (this may not be its final value)

        - however, the vlaue of `z[i-l]` might be too large (it could exceed `r`, `i + z[i-l] > r` and
          we do not know anything about the string past the character at index `r`)

        - so the initial estimate for `z[i]` can be made as `z0[i]= min(r-i+1, z[i-1])`

---

## Z-Algorithm - Take Two



```
z compute( s )
    n = length of s
    create z array of length n initialized to zero
    l = 0,  r = 0
    for i = 1...n
        if (i <= r)
            z[i] = min (r - i + 1, z[i - l])  // estimate z[i]
        while i + z[i] < n && s[z[i]] == s[i + z[i]])
            increment z[i]
        if i + z[i] - 1 > r
            l = i
            r = i + z[i] - 1
    return z
```
--

<br/>
<br/>

this is $O(n)$, for a proof see, for example, https://cp-algorithms.com/string/z-function.html

--
Visualization:
[http://www.utdallas.edu/~besp/demo/John2010/z-algorithm.htm](http://www.utdallas.edu/~besp/demo/John2010/z-algorithm.htm)


---

class: challenge

# Challenge: Pattern Matching

Find all locations of a pattern string `p` in a given string `s`.

--

__Solution__

- create a new string `p#s` in which `#` is a special character that does not
occur in neither `p` nor `s`
- create the z-array for the new string
- the locations in the z-array for which the value is equal to the length
of the pattern string `p` are the location of the pattern in `s` (adjust indexes
by subtracting the `length(p)+1`)

--

[Visualization of the solution](https://algorithm-visualizer.org/dynamic-programming/z-string-search)


---

class: challenge

# Challenge: Finding Borders



A __border__ in a string is a substring that is both a prefix and a sufix of that
string (but not the entire string, i.e., proper prefix and proper suffix).

Example:

`s = ABACABACABA`

the borders are

```
          -
A         ABACABACABA
                    -

          ---
ABA       ABACABACABA
                  ---

          -------
ABACABA   ABACABACABA
              -------


```


---

# Challenge: Finding Borders


__Solution__

- create the z-array for `s`
- boarders are all suffixes `s[k..n-1]`, such that `k+z[k]=n`


```
index   0  1  2  3  4  5  6  7  8  9 10
  s     A  B  A  C  A  B  A  C  A  B  A
  Z     -  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?

```

--

```
index   0  1  2  3  4  5  6  7  8  9 10
  s     A  B  A  C  A  B  A  C  A  B  A
  Z     -  0  1  0  7  0  1  0  3  0  1

                    |           |     |

```

---

# Knuth-Morris-Pratt’s (KMP) Algorithm

Another algorithm for pattern matching in strings.

It uses the observation that when a mismatch occurs,
the pattern itself contains sufficient information to
determine where the next match could begin. This allows to
skip re-examination of previously matched characters.

Example of the idea:

```
                    1         2
index:    01234567890123456789012
string:   ABC ABCDAB ABCDABCDABDE
pattern:  ABCDABD
```


---

# Knuth-Morris-Pratt’s (KMP) Algorithm

Another algorithm for pattern matching in strings.

It uses the observation that when a mismatch occurs,
the pattern itself contains sufficient information to
determine where the next match could begin. This allows to
skip re-examination of previously matched characters.

Example of the idea:

```
                    1         2
index:    01234567890123456789012
string:   ABC ABCDAB ABCDABCDABDE
pattern:  ABCDABD
          1110
```

---

# Knuth-Morris-Pratt’s (KMP) Algorithm

Another algorithm for pattern matching in strings.

It uses the observation that when a mismatch occurs,
the pattern itself contains sufficient information to
determine where the next match could begin. This allows to
skip re-examination of previously matched characters.

Example of the idea:

```
                    1         2
index:    01234567890123456789012
string:   ABC ABCDAB ABCDABCDABDE
pattern:     ABCDABD

```


---

# Knuth-Morris-Pratt’s (KMP) Algorithm

Another algorithm for pattern matching in strings.

It uses the observation that when a mismatch occurs,
the pattern itself contains sufficient information to
determine where the next match could begin. This allows to
skip re-examination of previously matched characters.

Example of the idea:

```
                    1         2
index:    01234567890123456789012
string:   ABC ABCDAB ABCDABCDABDE
pattern:      ABCDABD

```


---

# Knuth-Morris-Pratt’s (KMP) Algorithm

Another algorithm for pattern matching in strings.

It uses the observation that when a mismatch occurs,
the pattern itself contains sufficient information to
determine where the next match could begin. This allows to
skip re-examination of previously matched characters.

Example of the idea:

```
                    1         2
index:    01234567890123456789012
string:   ABC ABCDAB ABCDABCDABDE
pattern:      ABCDABD
              1111110
```
---

# Knuth-Morris-Pratt’s (KMP) Algorithm

Another algorithm for pattern matching in strings.

It uses the observation that when a mismatch occurs,
the pattern itself contains sufficient information to
determine where the next match could begin. This allows to
skip re-examination of previously matched characters.

Example of the idea:

```
                    1         2
index:    01234567890123456789012
string:   ABC ABCDAB ABCDABCDABDE
pattern:          ABCDABD
                  110
```
---

# Knuth-Morris-Pratt’s (KMP) Algorithm

Another algorithm for pattern matching in strings.

It uses the observation that when a mismatch occurs,
the pattern itself contains sufficient information to
determine where the next match could begin. This allows to
skip re-examination of previously matched characters.

Example of the idea:

```
                    1         2
index:    01234567890123456789012
string:   ABC ABCDAB ABCDABCDABDE
pattern:            ABCDABD
                    0
```
---

# Knuth-Morris-Pratt’s (KMP) Algorithm

Another algorithm for pattern matching in strings.

It uses the observation that when a mismatch occurs,
the pattern itself contains sufficient information to
determine where the next match could begin. This allows to
skip re-examination of previously matched characters.

Example of the idea:

```
                    1         2
index:    01234567890123456789012
string:   ABC ABCDAB ABCDABCDABDE
pattern:             ABCDABD
                     1111110
```
---

# Knuth-Morris-Pratt’s (KMP) Algorithm

Another algorithm for pattern matching in strings.

It uses the observation that when a mismatch occurs,
the pattern itself contains sufficient information to
determine where the next match could begin. This allows to
skip re-examination of previously matched characters.

Example of the idea:

```
                    1         2
index:    01234567890123456789012
string:   ABC ABCDAB ABCDABCDABDE
pattern:                 ABCDABD
                         1111111   match found
```

--


[Visualization of KMP](http://www.whocouldthat.be/visualizing-string-matching/)

[another visualization of KMP](https://people.ok.ubc.ca/ylucet/DS/KnuthMorrisPratt.html)


Souce code implementation: [cpp](slides/12/kmp.cpp), [java](slides/12/kmp.java)






---


</optgroup>



    </textarea>
     <script src="js/remark.js" type="text/javascript">
    </script>
    <script src="js/remark_conf.js" type="text/javascript">
    </script>

    <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<script type="text/x-mathjax-config">
   MathJax.Hub.Config({
     extensions: ["tex2jax.js"],
     jax: ["input/TeX", "output/HTML-CSS"],
     tex2jax: {
       inlineMath: [ ['$','$'], ["\\(","\\)"] ],
       displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
       processEscapes: true
     },
     "HTML-CSS": { availableFonts: ["TeX"] }
   });
</script>


  </body>
</html>
